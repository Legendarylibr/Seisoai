/**
 * Provenance Service — ERC-8004 provenance layer with Pinata Private IPFS.
 *
 * Everything on-chain + Pinata. Zero database dependency.
 *
 *   ON-CHAIN:  contentHash, agentId, outputType, timestamp, owner, privateCid
 *   PINATA:    actual file bytes (private, signed URL access only)
 *   MONGODB:   nothing
 *
 * Flow per AI generation:
 *   1. Download raw output from FAL CDN
 *   2. Compute keccak256 of raw bytes → contentHash
 *   3. Upload to Pinata Private IPFS → privateCid
 *   4. Mint ERC-721 provenance NFT with contentHash + privateCid on-chain
 *
 * File access (ownership-gated):
 *   1. User calls POST /provenance/access with tokenId + walletAddress
 *   2. Backend checks ownerOf(tokenId) on-chain
 *   3. Backend reads privateCid from chain via getPrivateCid(tokenId)
 *   4. Backend generates time-limited Pinata signed URL → returns to user
 *
 * The privateCid is safe on-chain because Pinata Private IPFS is NOT public IPFS.
 * The CID is just an identifier — accessing the file requires a signed URL
 * generated by the platform's PINATA_JWT.
 *
 * Platform pays all gas. NFT goes to user's wallet if connected, else platform vault.
 */
import { ethers } from 'ethers';
import logger from '../utils/logger.js';
import config from '../config/env.js';
import { getProvider } from './blockchain.js';
import {
  uploadToPrivateIPFS,
  createSignedAccessUrl,
  downloadAndHash,
  isPinataConfigured,
} from './pinataService.js';

// ── ABI fragments ──────────────────────────────────────────────────────

const PROVENANCE_NFT_ABI = [
  'function mint(address recipient, bytes32 contentHash, uint256 agentId, uint8 outputType, string privateCid) external returns (uint256)',
  'function getProvenance(uint256 tokenId) external view returns (bytes32 contentHash, uint256 agentId, uint8 outputType, uint64 timestamp, address owner_)',
  'function getPrivateCid(uint256 tokenId) external view returns (string)',
  'function tokenByHash(bytes32 contentHash) external view returns (uint256)',
  'function isHashMinted(bytes32 contentHash) external view returns (bool)',
  'function ownerOf(uint256 tokenId) external view returns (address)',
  'function tokenURI(uint256 tokenId) external view returns (string)',
];

const VALIDATION_REGISTRY_ABI = [
  'function validationRequest(address validatorAddress, uint256 agentId, string requestURI, bytes32 requestHash) external',
  'function validationResponse(bytes32 requestHash, uint8 response, string responseURI, bytes32 responseHash, string tag) external',
];

// ── Output type enum (mirrors contract) ─────────────────────────────────

const OUTPUT_TYPE: Record<string, number> = {
  image: 0,
  video: 1,
  music: 2,
  chat: 3,
};

// ── Public types ────────────────────────────────────────────────────────

export interface RecordProvenanceInput {
  agentId: number;
  agentRegistry: string;
  chainId: number;
  type: 'image' | 'video' | 'music' | 'chat';
  resultUrl: string;
  /** Wallet address to receive the provenance NFT. Falls back to signer. */
  recipient?: string;
}

export interface ProvenanceResult {
  tokenId: number;
  contentHash: string;
  agentId: number;
  outputType: string;
  txHash: string;
  /** Whether the file was stored on Pinata Private IPFS. */
  pinataStored: boolean;
}

export interface ProvenanceVerification {
  exists: boolean;
  tokenId?: number;
  contentHash?: string;
  agentId?: number;
  outputType?: string;
  timestamp?: number;
  owner?: string;
  /** True if a private file is available via /provenance/access */
  hasPrivateFile?: boolean;
  tokenURI?: string;
}

// ── Core: record provenance ─────────────────────────────────────────────

/**
 * Full provenance pipeline — zero database dependency:
 *   1. Download output → hash raw bytes
 *   2. Upload to Pinata Private IPFS → privateCid
 *   3. Mint ERC-721 with contentHash + privateCid on-chain
 */
export async function recordProvenance(input: RecordProvenanceInput): Promise<ProvenanceResult | null> {
  let contentHash: string;
  let privateCid = '';

  // ── Step 1 + 2: Download, hash, and upload to Pinata Private IPFS ──
  if (isPinataConfigured()) {
    try {
      const downloaded = await downloadAndHash(input.resultUrl);
      if (downloaded) {
        contentHash = downloaded.contentHash;

        const urlPath = new URL(input.resultUrl).pathname;
        const ext = urlPath.split('.').pop() || inferExtension(input.type);
        const fileName = `${input.type}-${Date.now()}.${ext}`;

        const uploadResult = await uploadToPrivateIPFS(
          input.resultUrl,
          fileName,
          input.type,
        );

        if (uploadResult) {
          privateCid = uploadResult.cid;
        }
      } else {
        contentHash = ethers.keccak256(ethers.toUtf8Bytes(input.resultUrl));
      }
    } catch (err) {
      logger.warn('Pinata pipeline failed, falling back to URL hash', {
        error: (err as Error).message,
      });
      contentHash = ethers.keccak256(ethers.toUtf8Bytes(input.resultUrl));
    }
  } else {
    contentHash = ethers.keccak256(ethers.toUtf8Bytes(input.resultUrl));
  }

  // ── Step 3: Mint provenance NFT with contentHash + privateCid on-chain ──
  if (isNftProvenanceConfigured()) {
    try {
      const result = await mintProvenanceNft({
        contentHash,
        agentId: input.agentId,
        outputType: OUTPUT_TYPE[input.type] ?? 0,
        recipient: input.recipient,
        type: input.type,
        privateCid,
      });

      return {
        tokenId: result.tokenId,
        contentHash: result.contentHash,
        agentId: result.agentId,
        outputType: result.outputType,
        txHash: result.txHash,
        pinataStored: !!privateCid,
      };
    } catch (err) {
      logger.warn('Provenance NFT mint failed, falling back to validation anchor', {
        type: input.type,
        error: (err as Error).message,
      });
    }
  }

  // ── Fallback: Legacy ValidationRegistry anchor ────────────────────
  if (isValidationRegistryConfigured()) {
    try {
      await anchorViaValidationRegistry(input, contentHash);
      logger.info('Provenance anchored via ValidationRegistry (legacy)', {
        agentId: input.agentId,
        type: input.type,
        contentHash: contentHash.slice(0, 18) + '…',
      });
    } catch (err) {
      logger.warn('Provenance anchor failed', { type: input.type, error: (err as Error).message });
    }
  }

  return null;
}

// ── Mint provenance NFT ─────────────────────────────────────────────────

async function mintProvenanceNft(params: {
  contentHash: string;
  agentId: number;
  outputType: number;
  recipient?: string;
  type: string;
  privateCid: string;
}): Promise<{ tokenId: number; contentHash: string; agentId: number; outputType: string; txHash: string }> {
  const provider = getProvider(config.ERC8004_CHAIN_ID!);
  if (!provider) throw new Error('No provider for configured chain');

  const signer = new ethers.Wallet(config.ERC8004_PROVENANCE_SIGNER_PRIVATE_KEY!, provider);
  const provenanceNft = new ethers.Contract(
    config.ERC8004_PROVENANCE_NFT!,
    PROVENANCE_NFT_ABI,
    signer,
  );

  const recipient = params.recipient || signer.address;

  const tx = await provenanceNft.mint(
    recipient,
    params.contentHash,
    params.agentId,
    params.outputType,
    params.privateCid,
  );
  const receipt = await tx.wait();

  // Parse the ProvenanceMinted event to get the tokenId
  let tokenId = 0;
  for (const log of receipt.logs) {
    try {
      const parsed = provenanceNft.interface.parseLog({ topics: log.topics as string[], data: log.data });
      if (parsed?.name === 'ProvenanceMinted') {
        tokenId = Number(parsed.args.tokenId);
        break;
      }
    } catch {
      // not our event, skip
    }
  }

  logger.info('Provenance NFT minted', {
    tokenId,
    agentId: params.agentId,
    type: params.type,
    contentHash: params.contentHash.slice(0, 18) + '…',
    privateCid: params.privateCid ? params.privateCid.slice(0, 16) + '…' : '(none)',
    recipient,
    txHash: tx.hash,
  });

  return {
    tokenId,
    contentHash: params.contentHash,
    agentId: params.agentId,
    outputType: params.type,
    txHash: tx.hash,
  };
}

// ── Verify provenance ───────────────────────────────────────────────────

/**
 * Verify provenance by content hash or token ID.
 * Reads all data from chain — no database needed.
 */
export async function verifyProvenance(
  query: { contentHash?: string; tokenId?: number },
): Promise<ProvenanceVerification> {
  if (!isNftProvenanceConfigured()) {
    return { exists: false };
  }

  const provider = getProvider(config.ERC8004_CHAIN_ID!);
  if (!provider) return { exists: false };

  const provenanceNft = new ethers.Contract(
    config.ERC8004_PROVENANCE_NFT!,
    PROVENANCE_NFT_ABI,
    provider,
  );

  try {
    let tokenId: number;

    if (query.tokenId) {
      tokenId = query.tokenId;
    } else if (query.contentHash) {
      const hash = query.contentHash.startsWith('0x')
        ? query.contentHash
        : ethers.keccak256(ethers.toUtf8Bytes(query.contentHash));
      tokenId = Number(await provenanceNft.tokenByHash(hash));
      if (tokenId === 0) return { exists: false };
    } else {
      return { exists: false };
    }

    const [contentHash, agentId, outputType, timestamp, owner] =
      await provenanceNft.getProvenance(tokenId);

    const typeLabels = ['image', 'video', 'music', 'chat'];

    // Check if a private file exists on-chain (read CID from contract)
    let hasPrivateFile = false;
    try {
      const cid: string = await provenanceNft.getPrivateCid(tokenId);
      hasPrivateFile = cid.length > 0;
    } catch {
      // older contract without getPrivateCid
    }

    let tokenURI: string | undefined;
    try {
      tokenURI = await provenanceNft.tokenURI(tokenId);
    } catch {
      // may fail for burned tokens
    }

    return {
      exists: true,
      tokenId,
      contentHash,
      agentId: Number(agentId),
      outputType: typeLabels[outputType] ?? 'unknown',
      timestamp: Number(timestamp),
      owner,
      hasPrivateFile,
      tokenURI,
    };
  } catch {
    return { exists: false };
  }
}

/**
 * Look up provenance for a result URL (convenience wrapper).
 */
export async function verifyByResultUrl(resultUrl: string): Promise<ProvenanceVerification> {
  const contentHash = ethers.keccak256(ethers.toUtf8Bytes(resultUrl));
  return verifyProvenance({ contentHash });
}

// ── Ownership-gated file access (Pinata signed URL) ─────────────────────

/**
 * Verify NFT ownership on-chain, read privateCid from chain, and generate
 * a time-limited Pinata signed URL.  Zero database dependency.
 *
 * @param tokenId       The provenance NFT token ID.
 * @param walletAddress The wallet claiming ownership.
 * @param expires       Seconds until the signed URL expires (default 300).
 */
export async function getSignedUrlForOwner(
  tokenId: number,
  walletAddress: string,
  expires: number = 300,
): Promise<{
  signedUrl: string;
  tokenId: number;
  expiresInSeconds: number;
} | null> {
  if (!isNftProvenanceConfigured()) return null;
  if (!isPinataConfigured()) return null;

  const provider = getProvider(config.ERC8004_CHAIN_ID!);
  if (!provider) return null;

  const provenanceNft = new ethers.Contract(
    config.ERC8004_PROVENANCE_NFT!,
    PROVENANCE_NFT_ABI,
    provider,
  );

  // 1. Verify ownership on-chain
  const owner: string = await provenanceNft.ownerOf(tokenId);
  if (owner.toLowerCase() !== walletAddress.toLowerCase()) {
    return null; // Not the owner
  }

  // 2. Read privateCid from chain
  const privateCid: string = await provenanceNft.getPrivateCid(tokenId);
  if (!privateCid) {
    return null; // No file stored on Private IPFS
  }

  // 3. Generate signed URL via Pinata
  const signedUrl = await createSignedAccessUrl(privateCid, expires);
  if (!signedUrl) return null;

  return {
    signedUrl,
    tokenId,
    expiresInSeconds: expires,
  };
}

// ── Legacy ValidationRegistry anchor ────────────────────────────────────

interface MinimalPayload {
  agentId: number;
  agentRegistry: string;
  chainId: number;
  type: string;
  contentHash: string;
  timestamp: string;
}

function canonicalize(obj: Record<string, unknown>): Record<string, unknown> {
  const sorted: Record<string, unknown> = {};
  for (const key of Object.keys(obj).sort()) {
    const v = obj[key];
    sorted[key] = v !== null && typeof v === 'object' && !Array.isArray(v)
      ? canonicalize(v as Record<string, unknown>)
      : v;
  }
  return sorted;
}

function toCanonicalJson(obj: Record<string, unknown>): string {
  return JSON.stringify(canonicalize(obj));
}

async function anchorViaValidationRegistry(input: RecordProvenanceInput, contentHash: string): Promise<void> {
  const provider = getProvider(config.ERC8004_CHAIN_ID!);
  if (!provider) return;

  const signer = new ethers.Wallet(config.ERC8004_PROVENANCE_SIGNER_PRIVATE_KEY!, provider);
  const validationRegistry = new ethers.Contract(
    config.ERC8004_VALIDATION_REGISTRY!,
    VALIDATION_REGISTRY_ABI,
    signer,
  );

  const timestamp = new Date().toISOString();
  const payload: MinimalPayload = {
    agentId: input.agentId,
    agentRegistry: input.agentRegistry,
    chainId: input.chainId,
    type: input.type,
    contentHash,
    timestamp,
  };

  const canonical = toCanonicalJson(payload as unknown as Record<string, unknown>);
  const requestHash = ethers.keccak256(ethers.toUtf8Bytes(canonical));
  const requestUri = `data:application/json;base64,${Buffer.from(canonical, 'utf8').toString('base64')}`;

  await validationRegistry.validationRequest(
    config.ERC8004_VALIDATOR_ADDRESS!,
    input.agentId,
    requestUri,
    requestHash,
  );

  await validationRegistry.validationResponse(
    requestHash,
    100,
    requestUri,
    requestHash,
    input.type,
  );
}

// ── Helpers ─────────────────────────────────────────────────────────────

function inferExtension(type: string): string {
  switch (type) {
    case 'image': return 'png';
    case 'video': return 'mp4';
    case 'music': return 'mp3';
    case 'chat':  return 'txt';
    default:      return 'bin';
  }
}

// ── Configuration checks ────────────────────────────────────────────────

/** Whether the ERC-721 provenance NFT contract is configured. */
export function isNftProvenanceConfigured(): boolean {
  return Boolean(
    config.ERC8004_PROVENANCE_NFT &&
    config.ERC8004_CHAIN_ID &&
    config.ERC8004_PROVENANCE_SIGNER_PRIVATE_KEY,
  );
}

/** Whether the legacy ValidationRegistry is configured. */
function isValidationRegistryConfigured(): boolean {
  return Boolean(
    config.ERC8004_VALIDATION_REGISTRY &&
    config.ERC8004_CHAIN_ID &&
    config.ERC8004_PROVENANCE_SIGNER_PRIVATE_KEY &&
    config.ERC8004_VALIDATOR_ADDRESS,
  );
}

/** Whether any provenance anchoring is configured (NFT or legacy). */
export function isProvenanceConfigured(): boolean {
  return isNftProvenanceConfigured() || isValidationRegistryConfigured();
}

/** Agent registry string for provenance (from config only). */
export function getProvenanceAgentRegistry(): string | null {
  if (!config.ERC8004_CHAIN_ID || !config.ERC8004_IDENTITY_REGISTRY) return null;
  return `eip155:${config.ERC8004_CHAIN_ID}:${config.ERC8004_IDENTITY_REGISTRY}`;
}
