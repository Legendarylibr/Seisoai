// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./IdentityRegistry.sol";

/**
 * @title AIOutputProvenance
 * @notice Minimal ERC-721 provenance layer for AI-generated outputs stored on
 *         Pinata Private IPFS.
 *
 * @dev Each token represents one AI generation.  On-chain storage per token:
 *        contentHash  – keccak256 of the raw file bytes (true content hash)
 *        agentId      – ERC-8004 agent that produced the output
 *        outputType   – 0 image | 1 video | 2 music | 3 chat
 *        timestamp    – block.timestamp at mint
 *        privateCid   – CID on Pinata Private IPFS (separate mapping)
 *
 *      The privateCid is safe on-chain because Pinata Private IPFS files are NOT
 *      on the public IPFS network.  The CID is just an identifier — accessing the
 *      actual file requires a signed URL generated by the platform's PINATA_JWT.
 *
 *      The tokenURI includes a "file" attribute with the private CID, following
 *      the pattern from "How to Manage AI Files with ERC-721" (Pinata, Jan 2026).
 *
 *      The platform signer funds all mints — users never need gas.
 *      Zero database dependency — everything lives on-chain + Pinata.
 */
contract AIOutputProvenance is ERC721, Ownable {
    // ── Storage ────────────────────────────────────────────────────────
    uint256 public nextTokenId = 1;

    struct Provenance {
        bytes32 contentHash;   // keccak256 of the raw output file
        uint256 agentId;       // ERC-8004 agent that produced the output
        uint8   outputType;    // 0 = image, 1 = video, 2 = music, 3 = chat
        uint64  timestamp;     // block.timestamp at mint
    }

    mapping(uint256 => Provenance) private _provenance;

    // Private IPFS CID per token (Pinata Private IPFS)
    mapping(uint256 => string) private _privateCids;

    // Reverse lookup: contentHash → tokenId (0 means not minted)
    mapping(bytes32 => uint256) private _hashToToken;

    // Reference to the Identity Registry (optional, for agent existence checks)
    IdentityRegistry public identityRegistry;

    // ── Events ─────────────────────────────────────────────────────────
    event ProvenanceMinted(
        uint256 indexed tokenId,
        bytes32 indexed contentHash,
        uint256 indexed agentId,
        uint8   outputType,
        address recipient,
        string  privateCid
    );

    // ── Constructor ────────────────────────────────────────────────────
    constructor(address _identityRegistry)
        ERC721("AI Output Provenance", "AIPROV")
        Ownable(msg.sender)
    {
        identityRegistry = IdentityRegistry(_identityRegistry);
    }

    // ── Mint ───────────────────────────────────────────────────────────

    /**
     * @notice Mint a provenance token for an AI output.
     * @param recipient   Address that receives the NFT (user wallet or platform vault).
     * @param contentHash keccak256 hash of the raw output file bytes.
     * @param agentId     The ERC-8004 agent ID that produced the output.
     * @param outputType  0 = image, 1 = video, 2 = music, 3 = chat.
     * @param privateCid  CID of the file on Pinata Private IPFS (can be empty).
     * @return tokenId    The newly minted token ID.
     */
    function mint(
        address recipient,
        bytes32 contentHash,
        uint256 agentId,
        uint8   outputType,
        string  calldata privateCid
    ) external onlyOwner returns (uint256 tokenId) {
        require(contentHash != bytes32(0), "Empty content hash");
        require(_hashToToken[contentHash] == 0, "Hash already minted");
        require(outputType <= 3, "Invalid output type");

        tokenId = nextTokenId++;

        _safeMint(recipient, tokenId);

        _provenance[tokenId] = Provenance({
            contentHash: contentHash,
            agentId:     agentId,
            outputType:  outputType,
            timestamp:   uint64(block.timestamp)
        });

        if (bytes(privateCid).length > 0) {
            _privateCids[tokenId] = privateCid;
        }

        _hashToToken[contentHash] = tokenId;

        emit ProvenanceMinted(tokenId, contentHash, agentId, outputType, recipient, privateCid);
    }

    // ── Read helpers ───────────────────────────────────────────────────

    /**
     * @notice Get provenance data for a token.
     */
    function getProvenance(uint256 tokenId) external view returns (
        bytes32 contentHash,
        uint256 agentId,
        uint8   outputType,
        uint64  timestamp,
        address owner_
    ) {
        require(_exists(tokenId), "Token does not exist");
        Provenance storage p = _provenance[tokenId];
        return (p.contentHash, p.agentId, p.outputType, p.timestamp, ownerOf(tokenId));
    }

    /**
     * @notice Get the Private IPFS CID for a token.
     */
    function getPrivateCid(uint256 tokenId) external view returns (string memory) {
        require(_exists(tokenId), "Token does not exist");
        return _privateCids[tokenId];
    }

    /**
     * @notice Look up a token by its content hash (returns 0 if not found).
     */
    function tokenByHash(bytes32 contentHash) external view returns (uint256) {
        return _hashToToken[contentHash];
    }

    /**
     * @notice Verify whether a content hash has been minted.
     */
    function isHashMinted(bytes32 contentHash) external view returns (bool) {
        return _hashToToken[contentHash] != 0;
    }

    // ── Token URI (fully on-chain) ─────────────────────────────────────

    /**
     * @notice Returns a base64-encoded JSON data URI with provenance metadata.
     *         Includes a "file" attribute with the Pinata Private IPFS CID.
     */
    function tokenURI(uint256 tokenId) public view override returns (string memory) {
        require(_exists(tokenId), "Token does not exist");
        Provenance storage p = _provenance[tokenId];
        string storage cid = _privateCids[tokenId];

        string memory outputLabel;
        if (p.outputType == 0) outputLabel = "image";
        else if (p.outputType == 1) outputLabel = "video";
        else if (p.outputType == 2) outputLabel = "music";
        else outputLabel = "chat";

        // Build JSON — includes "file" key for Private IPFS CID (Pinata pattern)
        string memory json = string(abi.encodePacked(
            '{"name":"AI Provenance #', _toString(tokenId), '",',
            '"description":"Provenance record for AI-generated ', outputLabel, '",',
            '"file":"', cid, '",',
            '"attributes":[',
                '{"trait_type":"contentHash","value":"', _bytes32ToHex(p.contentHash), '"},',
                '{"trait_type":"agentId","value":"', _toString(p.agentId), '"},',
                '{"trait_type":"outputType","value":"', outputLabel, '"},',
                '{"trait_type":"timestamp","value":"', _toString(uint256(p.timestamp)), '"}',
            ']}'
        ));

        return string(abi.encodePacked(
            "data:application/json;base64,",
            _base64Encode(bytes(json))
        ));
    }

    // ── Admin ──────────────────────────────────────────────────────────

    /**
     * @notice Update the Identity Registry reference.
     */
    function setIdentityRegistry(address _identityRegistry) external onlyOwner {
        identityRegistry = IdentityRegistry(_identityRegistry);
    }

    // ── Internal helpers ───────────────────────────────────────────────

    function _exists(uint256 tokenId) internal view returns (bool) {
        return tokenId > 0 && tokenId < nextTokenId;
    }

    function _toString(uint256 value) internal pure returns (string memory) {
        if (value == 0) return "0";
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) { digits++; temp /= 10; }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits--;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }

    function _bytes32ToHex(bytes32 data) internal pure returns (string memory) {
        bytes memory alphabet = "0123456789abcdef";
        bytes memory str = new bytes(66); // "0x" + 64 hex chars
        str[0] = "0";
        str[1] = "x";
        for (uint256 i = 0; i < 32; i++) {
            str[2 + i * 2]     = alphabet[uint8(data[i] >> 4)];
            str[2 + i * 2 + 1] = alphabet[uint8(data[i] & 0x0f)];
        }
        return string(str);
    }

    // Minimal base64 encoder (no external dependency)
    function _base64Encode(bytes memory data) internal pure returns (string memory) {
        bytes memory TABLE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        if (data.length == 0) return "";
        uint256 encodedLen = 4 * ((data.length + 2) / 3);
        bytes memory result = new bytes(encodedLen);
        uint256 i;
        uint256 j;
        for (i = 0; i + 2 < data.length; i += 3) {
            uint256 n = uint256(uint8(data[i])) << 16 |
                        uint256(uint8(data[i + 1])) << 8 |
                        uint256(uint8(data[i + 2]));
            result[j++] = TABLE[(n >> 18) & 0x3F];
            result[j++] = TABLE[(n >> 12) & 0x3F];
            result[j++] = TABLE[(n >>  6) & 0x3F];
            result[j++] = TABLE[n & 0x3F];
        }
        if (data.length % 3 == 1) {
            uint256 n = uint256(uint8(data[i])) << 16;
            result[j++] = TABLE[(n >> 18) & 0x3F];
            result[j++] = TABLE[(n >> 12) & 0x3F];
            result[j++] = "=";
            result[j++] = "=";
        } else if (data.length % 3 == 2) {
            uint256 n = uint256(uint8(data[i])) << 16 |
                        uint256(uint8(data[i + 1])) << 8;
            result[j++] = TABLE[(n >> 18) & 0x3F];
            result[j++] = TABLE[(n >> 12) & 0x3F];
            result[j++] = TABLE[(n >>  6) & 0x3F];
            result[j++] = "=";
        }
        return string(result);
    }
}
