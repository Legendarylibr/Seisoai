<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    
    <!-- PERFORMANCE: Preconnect to image CDNs for faster image loading -->
    <link rel="preconnect" href="https://fal.media" crossorigin />
    <link rel="preconnect" href="https://v3.fal.media" crossorigin />
    <link rel="dns-prefetch" href="https://fal.media" />
    <link rel="dns-prefetch" href="https://v3.fal.media" />
    
    <link rel="icon" type="image/png" href="/1d1c7555360a737bb22bbdfc2784655f.png" />
    <link rel="shortcut icon" href="/1d1c7555360a737bb22bbdfc2784655f.png" />
    <link rel="apple-touch-icon" href="/1d1c7555360a737bb22bbdfc2784655f.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Seiso AI - Create and Edit Stunning AI-Generated Images</title>
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="Create and edit stunning AI-generated images with advanced image editing capabilities. Multi-image blending, style transfer, and professional-grade results." />
    <meta name="keywords" content="AI image generator, image editing, AI art, image editing, Nano Banana Pro, FLUX" />
    
    <!-- Open Graph / Facebook / Instagram -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://seisoai.com/" />
    <meta property="og:title" content="Seiso AI - Create and Edit Stunning AI-Generated Images" />
    <meta property="og:description" content="Create and edit stunning AI-generated images with advanced image editing capabilities. Multi-image blending, style transfer, and professional-grade results." />
    <meta property="og:image" content="https://seisoai.com/seiso6.png" />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta property="og:site_name" content="Seiso AI" />
    <meta property="og:locale" content="en_US" />
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:url" content="https://seisoai.com/" />
    <meta name="twitter:title" content="Seiso AI - Create and Edit Stunning AI-Generated Images" />
    <meta name="twitter:description" content="Create and edit stunning AI-generated images with advanced image editing capabilities. Multi-image blending, style transfer, and professional-grade results." />
    <meta name="twitter:image" content="https://seisoai.com/seiso6.png" />
    
    <!-- Security Headers with proper CSP for development -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://js.stripe.com https://checkout.stripe.com https://hooks.stripe.com https://static.cloudflareinsights.com; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://js.stripe.com; font-src 'self' https://fonts.gstatic.com data:; img-src 'self' data: https: blob: https://*.stripe.com; media-src 'self' data: blob: https:; connect-src 'self' http://localhost:3001 http://localhost:3000 http://localhost:5173 https://api.fal.ai https://api.mainnet-beta.solana.com https://solana-api.projectserum.com https://rpc.ankr.com https://solana-mainnet.g.alchemy.com https://mainnet.helius-rpc.com https://api.devnet.solana.com https://js.stripe.com https://api.stripe.com https://hooks.stripe.com https://checkout.stripe.com https://static.cloudflareinsights.com https: wss:; frame-src 'self' https://js.stripe.com https://checkout.stripe.com https://hooks.stripe.com; object-src 'none'; base-uri 'self'; form-action 'self';" />
    <meta http-equiv="X-Content-Type-Options" content="nosniff" />
    <meta http-equiv="X-XSS-Protection" content="1; mode=block" />
    
    <!-- Enhanced wallet conflict resolution - must run first -->
    <script>
      // CRITICAL: This must run IMMEDIATELY and SYNCHRONOUSLY before ANY other script
      // No IIFE wrapper - execute directly to ensure it runs first
      'use strict';
      
      // Prevent multiple executions
      if (window.__walletConflictResolutionSetup) {
        // Already set up, but ensure handlers are still active
      } else {
        window.__walletConflictResolutionSetup = true;
        
        (function() {
        
        // CRITICAL: Set up error handlers FIRST before anything else
        // This catches errors from evmAsk.js and other extension scripts
        const errorHandler = function(event) {
          const error = event.error || event;
          const message = (error?.message || event.message || '').toString();
          const stack = (error?.stack || event.error?.stack || '').toString();
          const filename = (event.filename || event.source || '').toString();
          
          // Catch ALL ethereum redefinition errors from evmAsk.js or any source
          if ((message.includes('Cannot redefine property') || 
              message.includes('Cannot define property')) &&
              (message.includes('ethereum') || 
               filename.includes('evmAsk') || 
               filename.includes('contentScript') ||
               stack.includes('evmAsk') ||
               stack.includes('contentScript'))) {
            event.preventDefault();
            event.stopPropagation();
            event.stopImmediatePropagation();
            return false;
          }
          
          // Catch ANY errors from evmAsk.js or contentScript.js related to defineProperty
          if ((filename.includes('evmAsk') || filename.includes('contentScript') || 
               stack.includes('evmAsk') || stack.includes('contentScript')) && 
              (message.includes('defineProperty') || 
               message.includes('TypeError') ||
               message.includes('Cannot redefine') ||
               message.includes('Cannot define'))) {
            event.preventDefault();
            event.stopPropagation();
            event.stopImmediatePropagation();
            return false;
          }
        };
        
        // Register error handler with highest priority (capture phase)
        window.addEventListener('error', errorHandler, true);
        
        // CRITICAL: Make any existing ethereum property configurable BEFORE anything else
        // This ensures wallet extensions can redefine it without errors
        try {
          if (window.ethereum) {
            const ethereumDescriptor = Object.getOwnPropertyDescriptor(window, 'ethereum');
            if (ethereumDescriptor && !ethereumDescriptor.configurable) {
              // Try to make it configurable by deleting and redefining
              try {
                delete window.ethereum;
              } catch (e) {
                // If delete fails, we'll handle it in the defineProperty override
              }
            }
          }
        } catch (e) {
          // Silent - we'll handle this in defineProperty
        }
        
        // Store original methods BEFORE any other scripts can modify them
        const originalDefineProperty = Object.defineProperty;
        const originalDefineProperties = Object.defineProperties;
        
        // ULTRA-AGGRESSIVE defineProperty override - prevent ALL redefinition errors
        Object.defineProperty = function(obj, prop, descriptor) {
          // Handle ethereum property redefinition gracefully - ALWAYS prevent errors
          if (prop === 'ethereum' && obj === window) {
            // If ethereum already exists, NEVER try to redefine - just return window
            // This completely prevents errors from evmAsk.js and other wallet extensions
            if (window.ethereum !== undefined) {
              // Merge new properties if descriptor has value/get/set
              if (descriptor && descriptor.value !== undefined) {
                // Try to merge properties if it's an object
                if (typeof descriptor.value === 'object' && descriptor.value !== null && 
                    typeof window.ethereum === 'object' && window.ethereum !== null) {
                  try {
                    Object.assign(window.ethereum, descriptor.value);
                  } catch (e) {
                    // If merge fails, just keep existing ethereum
                  }
                }
              }
              // Always return window (the object being modified), not the property value
              return window;
            }
            
            // First definition - ensure it's configurable so future redefinitions work
            try {
              const configurableDescriptor = {
                ...descriptor,
                configurable: true, // CRITICAL: Always make it configurable
                enumerable: descriptor.enumerable !== false,
                writable: descriptor.writable !== false
              };
              return originalDefineProperty.call(this, obj, prop, configurableDescriptor);
            } catch (error) {
              // If it fails for any reason, check if ethereum was set another way
              if (window.ethereum !== undefined) {
                return window;
              }
              // If still no ethereum, try with a fully permissive descriptor
              try {
                const permissiveDescriptor = {
                  ...descriptor,
                  configurable: true,
                  enumerable: true,
                  writable: true
                };
                return originalDefineProperty.call(this, obj, prop, permissiveDescriptor);
              } catch (e2) {
                // Last resort: set it directly and return window
                if (descriptor && descriptor.value !== undefined) {
                  window.ethereum = descriptor.value;
                } else {
                  window.ethereum = {};
                }
                return window;
              }
            }
          }
          
          // Handle ANY redefinition error gracefully
          try {
            return originalDefineProperty.call(this, obj, prop, descriptor);
          } catch (error) {
            // If it's a redefinition error, silently return the object being modified
            if (error && error.message && (
                error.message.includes('Cannot redefine property') ||
                error.message.includes('Cannot define property') ||
                error.name === 'TypeError'
              )) {
              // Silently return the object - no console warning
              // This is what Object.defineProperty should return anyway
              return obj;
            }
            // Only throw if it's not a redefinition error
            throw error;
          }
        };
        
        // Enhanced defineProperties override
        Object.defineProperties = function(obj, props) {
          if (obj === window && props.ethereum) {
            if (window.ethereum) {
              console.warn('üõ°Ô∏è Wallet conflict prevented: ethereum property already exists (defineProperties)');
              return window;
            }
          }
          return originalDefineProperties.call(this, obj, props);
        };
        
        // Store original functions
        window.originalDefineProperty = originalDefineProperty;
        window.originalDefineProperties = originalDefineProperties;
        
        // ULTRA-AGGRESSIVE: Override ALL error handling
        const originalOnError = window.onerror;
        const originalConsoleError = console.error;
        const originalConsoleWarn = console.warn;
        
        // Filter out harmless wallet redefinition errors from console
        console.error = function(...args) {
          const message = (args[0]?.toString?.() || '').toString();
          const fullMessage = args.map(a => a?.toString?.() || '').join(' ');
          const stack = (args.find(a => a?.stack)?.stack || '').toString();
          
          // EXTREMELY BROAD: Filter ALL ethereum redefinition errors
          if ((message.includes('Cannot redefine property') || 
               message.includes('Cannot define property')) && 
              (message.includes('ethereum') || 
               fullMessage.includes('ethereum') ||
               fullMessage.includes('evmAsk') ||
               fullMessage.includes('contentScript') ||
               stack.includes('evmAsk') ||
               stack.includes('contentScript'))) {
            return; // Silent - these are harmless
          }
          
          // Filter ANY errors from evmAsk or contentScript related to defineProperty
          if ((message.includes('evmAsk') || fullMessage.includes('evmAsk') ||
               message.includes('contentScript') || fullMessage.includes('contentScript') ||
               stack.includes('evmAsk') || stack.includes('contentScript')) && 
              (message.includes('defineProperty') || 
               message.includes('TypeError') ||
               message.includes('Cannot redefine') ||
               message.includes('Cannot define'))) {
            return; // Silent
          }
          
          return originalConsoleError.apply(this, args);
        };
        
        // Filter out wallet conflict warnings
        console.warn = function(...args) {
          const message = (args[0]?.toString?.() || '').toString();
          
          // Filter ethereum redefinition warnings
          if (message.includes('Cannot redefine property') && message.includes('ethereum')) {
            return; // Silent
          }
          
          return originalConsoleWarn.apply(this, args);
        };
        
        // Override the global error handler - silently catch wallet redefinition errors
        window.onerror = function(message, source, lineno, colno, error) {
          const msgStr = (message || '').toString();
          const srcStr = (source || '').toString();
          const errMsg = (error?.message || '').toString();
          const errStack = (error?.stack || '').toString();
          
          // EXTREMELY BROAD: Catch ALL variations of ethereum redefinition errors
          if ((msgStr.includes('Cannot redefine property') || 
               msgStr.includes('Cannot define property')) && 
              (msgStr.includes('ethereum') || 
               srcStr.includes('evmAsk') || 
               srcStr.includes('contentScript') ||
               errMsg.includes('ethereum') ||
               errStack.includes('evmAsk') ||
               errStack.includes('contentScript'))) {
            return true; // Prevent default error handling
          }
          
          // Catch ANY errors from evmAsk/contentScript related to defineProperty
          if ((srcStr.includes('evmAsk') || 
               srcStr.includes('contentScript') ||
               errMsg.includes('evmAsk') ||
               errStack.includes('evmAsk') ||
               errStack.includes('contentScript')) && 
              (msgStr.includes('defineProperty') || 
               msgStr.includes('TypeError') ||
               msgStr.includes('Cannot redefine') ||
               msgStr.includes('Cannot define'))) {
            return true;
          }
          
          if (originalOnError) {
            return originalOnError.call(this, message, source, lineno, colno, error);
          }
          return false;
        };
        
        // Handle unhandled promise rejections - silently catch wallet redefinition errors
        window.addEventListener('unhandledrejection', function(event) {
          const reason = event.reason;
          const message = (reason?.message || '').toString();
          const stack = (reason?.stack || '').toString();
          
          // EXTREMELY BROAD: Silently prevent ALL wallet-related promise rejections
          if ((message.includes('Cannot redefine property') || 
               message.includes('Cannot define property')) &&
              (message.includes('ethereum') || 
               stack.includes('evmAsk') ||
               stack.includes('contentScript'))) {
            event.preventDefault();
            event.stopPropagation();
            event.stopImmediatePropagation();
            // Silent - don't log
            return false;
          }
          
          // Catch ANY evmAsk/contentScript errors
          if ((message.includes('evmAsk') || 
               message.includes('contentScript') ||
               stack.includes('evmAsk') ||
               stack.includes('contentScript')) && 
              (message.includes('defineProperty') || 
               message.includes('TypeError') ||
               message.includes('Cannot redefine') ||
               message.includes('Cannot define'))) {
            event.preventDefault();
            event.stopPropagation();
            event.stopImmediatePropagation();
            // Silent - don't log
            return false;
          }
        }, true); // Use capture phase
        
        // Note: We no longer aggressively block script injection - we handle redefinition gracefully
        
        console.log('üõ°Ô∏è Enhanced wallet conflict resolution initialized');
        })();
      }
    </script>
  </head>
  <body>
    <div id="root"></div>
    <!-- CRITICAL: Buffer polyfill must run BEFORE any modules load (including Solana) -->
    <script>
      // Synchronously set up Buffer for Solana before any ES modules execute
      (function() {
        'use strict';
        // Simple Buffer polyfill for browser - will be replaced by full polyfill in main.jsx
        // This ensures window.Buffer exists before any lazy-loaded Solana code runs
        if (typeof window.Buffer === 'undefined') {
          // Create a minimal Buffer shim that works for Solana's basic needs
          // The full polyfill from 'buffer' package will override this
          window.Buffer = window.Buffer || {
            from: function(data, encoding) {
              if (typeof data === 'string') {
                if (encoding === 'base64') {
                  return Uint8Array.from(atob(data), c => c.charCodeAt(0));
                }
                return new TextEncoder().encode(data);
              }
              return new Uint8Array(data);
            },
            alloc: function(size) {
              return new Uint8Array(size);
            },
            isBuffer: function(obj) {
              return obj instanceof Uint8Array;
            },
            concat: function(list, length) {
              if (length === undefined) {
                length = list.reduce((acc, buf) => acc + buf.length, 0);
              }
              const result = new Uint8Array(length);
              let offset = 0;
              for (const buf of list) {
                result.set(buf, offset);
                offset += buf.length;
              }
              return result;
            }
          };
          window.global = window;
          console.log('üîß Buffer shim initialized for Solana');
        }
      })();
    </script>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>