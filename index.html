<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <link rel="shortcut icon" href="/vite.svg" />
    <link rel="apple-touch-icon" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Seiso AI</title>
    
    <!-- Security Headers with proper CSP for development -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://js.stripe.com https://checkout.stripe.com; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com; img-src 'self' data: https: blob:; connect-src 'self' http://localhost:3001 http://localhost:3000 http://localhost:5173 https://api.fal.ai https://api.mainnet-beta.solana.com https://solana-api.projectserum.com https://rpc.ankr.com https://solana-mainnet.g.alchemy.com https://mainnet.helius-rpc.com https://api.devnet.solana.com https: wss:; frame-src 'self' https://js.stripe.com https://checkout.stripe.com; object-src 'none'; base-uri 'self'; form-action 'self';" />
    <meta http-equiv="X-Content-Type-Options" content="nosniff" />
    <meta http-equiv="X-XSS-Protection" content="1; mode=block" />
    
    <!-- Enhanced wallet conflict resolution - must run first -->
    <script>
      (function() {
        'use strict';
        
        // Prevent multiple executions
        if (window.__walletConflictResolutionSetup) {
          return;
        }
        window.__walletConflictResolutionSetup = true;
        
        // AGGRESSIVE: Block evmAsk.js completely before it can load
        const originalFetch = window.fetch;
        const originalXHROpen = XMLHttpRequest.prototype.open;
        const originalXHRSend = XMLHttpRequest.prototype.send;
        
        // Block fetch requests to evmAsk.js
        window.fetch = function(...args) {
          const url = args[0];
          if (typeof url === 'string' && (url.includes('evmAsk') || url.includes('evmAsk.js'))) {
            console.warn('üõ°Ô∏è Blocked evmAsk.js fetch request:', url);
            return Promise.reject(new Error('evmAsk.js blocked by conflict resolution'));
          }
          return originalFetch.apply(this, args);
        };
        
        // Block XMLHttpRequest to evmAsk.js
        XMLHttpRequest.prototype.open = function(method, url, ...args) {
          if (typeof url === 'string' && (url.includes('evmAsk') || url.includes('evmAsk.js'))) {
            console.warn('üõ°Ô∏è Blocked evmAsk.js XHR request:', url);
            throw new Error('evmAsk.js blocked by conflict resolution');
          }
          return originalXHROpen.call(this, method, url, ...args);
        };
        
        // Store original methods
        const originalDefineProperty = Object.defineProperty;
        const originalDefineProperties = Object.defineProperties;
        
        // ULTRA-AGGRESSIVE defineProperty override
        Object.defineProperty = function(obj, prop, descriptor) {
          // COMPLETELY BLOCK ethereum property redefinition
          if (prop === 'ethereum' && obj === window) {
            console.warn('üõ°Ô∏è BLOCKED: ethereum property redefinition attempt');
            console.warn('üõ°Ô∏è Stack trace:', new Error().stack);
            
            // Always return the existing ethereum object or create a safe one
            if (window.ethereum) {
              return window.ethereum;
            }
            
            // Create a safe ethereum object that won't conflict
            const safeEthereum = {
              isMetaMask: false,
              isRabby: false,
              isCoinbaseWallet: false,
              isWalletConnect: false,
              request: function() {
                console.warn('üõ°Ô∏è Safe ethereum object used - no wallet connected');
                return Promise.reject(new Error('No wallet connected'));
              },
              on: function() {},
              removeListener: function() {},
              addListener: function() {}
            };
            
            try {
              return originalDefineProperty.call(this, obj, prop, {
                value: safeEthereum,
                configurable: true,
                enumerable: true,
                writable: true
              });
            } catch (error) {
              console.warn('üõ°Ô∏è Safe ethereum fallback applied');
              window.ethereum = safeEthereum;
              return safeEthereum;
            }
          }
          
          // Prevent originalDefineProperty conflicts
          if (prop === 'originalDefineProperty' && obj === window) {
            if (window.originalDefineProperty) {
              console.warn('üõ°Ô∏è Wallet conflict prevented: originalDefineProperty already exists');
              return window.originalDefineProperty;
            }
          }
          
          // Prevent other common wallet conflicts
          if (prop === 'defineProperty' && obj === Object) {
            if (window.originalDefineProperty) {
              console.warn('üõ°Ô∏è Wallet conflict prevented: defineProperty already exists');
              return window.originalDefineProperty;
            }
          }
          
          try {
            return originalDefineProperty.call(this, obj, prop, descriptor);
          } catch (error) {
            // If it's a redefinition error, just return the existing property
            if (error.message.includes('Cannot redefine property')) {
              console.warn('üõ°Ô∏è Property redefinition prevented:', prop);
              return obj[prop];
            }
            throw error;
          }
        };
        
        // Enhanced defineProperties override
        Object.defineProperties = function(obj, props) {
          if (obj === window && props.ethereum) {
            if (window.ethereum) {
              console.warn('üõ°Ô∏è Wallet conflict prevented: ethereum property already exists (defineProperties)');
              return window;
            }
          }
          return originalDefineProperties.call(this, obj, props);
        };
        
        // Store original functions
        window.originalDefineProperty = originalDefineProperty;
        window.originalDefineProperties = originalDefineProperties;
        
        // Global error handler for wallet conflicts
        const originalError = console.error;
        console.error = function(...args) {
          const message = args[0]?.toString?.() || '';
          
          // Filter out wallet conflict errors
          if (message.includes('Cannot redefine property: ethereum') ||
              message.includes('originalDefineProperty') ||
              message.includes('evmAsk.js') ||
              message.includes('inject')) {
            console.warn('üõ°Ô∏è Wallet conflict error filtered:', message);
            return;
          }
          
          originalError.apply(console, args);
        };
        
        // Handle uncaught errors
        window.addEventListener('error', function(event) {
          const error = event.error;
          const message = error?.message || '';
          const stack = error?.stack || '';
          const filename = event.filename || '';
          
          // Prevent ethereum property redefinition errors
          if (message.includes('Cannot redefine property: ethereum') ||
              message.includes('originalDefineProperty') ||
              message.includes('evmAsk.js') ||
              stack.includes('evmAsk.js') ||
              filename.includes('evmAsk.js') ||
              message.includes('Cannot redefine property') ||
              message.includes('inject') ||
              stack.includes('inject')) {
            event.preventDefault();
            event.stopPropagation();
            console.warn('üõ°Ô∏è Wallet conflict error prevented:', message);
            return false;
          }
        });
        
        // ULTRA-AGGRESSIVE: Override ALL error handling
        const originalOnError = window.onerror;
        const originalConsoleError = console.error;
        const originalConsoleWarn = console.warn;
        
        // Override console.error to filter out wallet conflicts
        console.error = function(...args) {
          const message = args[0]?.toString?.() || '';
          if (message.includes('Cannot redefine property: ethereum') ||
              message.includes('evmAsk.js') ||
              message.includes('inject') ||
              message.includes('originalDefineProperty')) {
            console.warn('üõ°Ô∏è Console error filtered:', message);
            return;
          }
          return originalConsoleError.apply(this, args);
        };
        
        // Override console.warn to filter out wallet conflicts
        console.warn = function(...args) {
          const message = args[0]?.toString?.() || '';
          if (message.includes('Cannot redefine property: ethereum') ||
              message.includes('evmAsk.js') ||
              message.includes('inject')) {
            return; // Don't show these warnings
          }
          return originalConsoleWarn.apply(this, args);
        };
        
        // Override the global error handler
        window.onerror = function(message, source, lineno, colno, error) {
          if (message && (
              message.includes('Cannot redefine property: ethereum') ||
              message.includes('evmAsk.js') ||
              message.includes('inject') ||
              message.includes('originalDefineProperty') ||
              (source && source.includes('evmAsk')) ||
              (error && error.stack && error.stack.includes('evmAsk'))
            )) {
            console.warn('üõ°Ô∏è Global error handler prevented wallet conflict:', message);
            return true; // Prevent default error handling
          }
          if (originalOnError) {
            return originalOnError.call(this, message, source, lineno, colno, error);
          }
          return false;
        };
        
        // Handle unhandled promise rejections
        window.addEventListener('unhandledrejection', function(event) {
          const reason = event.reason;
          const message = reason?.message || '';
          const stack = reason?.stack || '';
          
          // Prevent wallet-related promise rejections
          if (message.includes('Cannot redefine property: ethereum') ||
              message.includes('originalDefineProperty') ||
              message.includes('evmAsk.js') ||
              stack.includes('evmAsk.js') ||
              message.includes('Cannot redefine property')) {
            event.preventDefault();
            event.stopPropagation();
            console.warn('üõ°Ô∏è Wallet conflict promise rejection prevented:', message);
            return false;
          }
        });
        
        // ULTRA-AGGRESSIVE: Intercept ALL script creation and injection
        const originalCreateElement = document.createElement;
        const originalCreateElementNS = document.createElementNS;
        const originalWrite = document.write;
        const originalWriteln = document.writeln;
        
        // Block document.write/writeln
        document.write = function(content) {
          if (typeof content === 'string' && content.includes('evmAsk')) {
            console.warn('üõ°Ô∏è Blocked evmAsk.js via document.write');
            return;
          }
          return originalWrite.call(this, content);
        };
        
        document.writeln = function(content) {
          if (typeof content === 'string' && content.includes('evmAsk')) {
            console.warn('üõ°Ô∏è Blocked evmAsk.js via document.writeln');
            return;
          }
          return originalWriteln.call(this, content);
        };
        
        // Block createElementNS
        document.createElementNS = function(namespaceURI, qualifiedName) {
          const element = originalCreateElementNS.call(this, namespaceURI, qualifiedName);
          if (qualifiedName.toLowerCase() === 'script') {
            return createBlockedScriptElement(element);
          }
          return element;
        };
        
        // Enhanced script element creation
        document.createElement = function(tagName) {
          const element = originalCreateElement.call(this, tagName);
          
          if (tagName.toLowerCase() === 'script') {
            return createBlockedScriptElement(element);
          }
          
          return element;
        };
        
        function createBlockedScriptElement(element) {
          const originalSetAttribute = element.setAttribute;
          const originalAppendChild = element.appendChild;
          const originalInsertBefore = element.insertBefore;
          const originalInnerHTML = Object.getOwnPropertyDescriptor(Element.prototype, 'innerHTML');
          
          // Block src attribute
          element.setAttribute = function(name, value) {
            if (name === 'src' && typeof value === 'string') {
              if (value.includes('evmAsk.js') || 
                  value.includes('evmAsk') ||
                  (value.includes('wallet') && value.includes('inject'))) {
                console.warn('üõ°Ô∏è Blocked problematic wallet script:', value);
                return; // Don't set the src
              }
            }
            return originalSetAttribute.call(this, name, value);
          };
          
          // Block innerHTML changes
          Object.defineProperty(element, 'innerHTML', {
            set: function(value) {
              if (typeof value === 'string' && value.includes('evmAsk')) {
                console.warn('üõ°Ô∏è Blocked evmAsk.js via innerHTML');
                return;
              }
              if (originalInnerHTML && originalInnerHTML.set) {
                originalInnerHTML.set.call(this, value);
              }
            },
            get: function() {
              if (originalInnerHTML && originalInnerHTML.get) {
                return originalInnerHTML.get.call(this);
              }
              return '';
            },
            configurable: true
          });
            
          // Override appendChild to prevent script injection
          element.appendChild = function(child) {
            if (child.tagName === 'SCRIPT' && child.src && 
                (child.src.includes('evmAsk') || child.src.includes('evmAsk.js'))) {
              console.warn('üõ°Ô∏è Blocked script injection via appendChild:', child.src);
              return child; // Return the child but don't actually append
            }
            return originalAppendChild.call(this, child);
          };
            
          // Override insertBefore to prevent script injection
          element.insertBefore = function(newNode, referenceNode) {
            if (newNode.tagName === 'SCRIPT' && newNode.src && 
                (newNode.src.includes('evmAsk') || newNode.src.includes('evmAsk.js'))) {
              console.warn('üõ°Ô∏è Blocked script injection via insertBefore:', newNode.src);
              return newNode; // Return the node but don't actually insert
            }
            return originalInsertBefore.call(this, newNode, referenceNode);
          };
          
          return element;
        };
        
        // Also intercept document.head.appendChild and document.body.appendChild
        // Wait for DOM to be ready before setting up these interceptors
        function setupDOMInterceptors() {
          if (document.head) {
            const originalHeadAppendChild = document.head.appendChild;
            document.head.appendChild = function(child) {
              if (child.tagName === 'SCRIPT' && child.src && 
                  (child.src.includes('evmAsk') || child.src.includes('evmAsk.js'))) {
                console.warn('üõ°Ô∏è Blocked script injection via head.appendChild:', child.src);
                return child;
              }
              return originalHeadAppendChild.call(this, child);
            };
          }
          
          if (document.body) {
            const originalBodyAppendChild = document.body.appendChild;
            document.body.appendChild = function(child) {
              if (child.tagName === 'SCRIPT' && child.src && 
                  (child.src.includes('evmAsk') || child.src.includes('evmAsk.js'))) {
                console.warn('üõ°Ô∏è Blocked script injection via body.appendChild:', child.src);
                return child;
              }
              return originalBodyAppendChild.call(this, child);
            };
          }
        }
        
        // Set up DOM interceptors when DOM is ready
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', setupDOMInterceptors);
        } else {
          setupDOMInterceptors();
        }
        
        console.log('üõ°Ô∏è Enhanced wallet conflict resolution initialized');
      })();
    </script>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>